---
title: Actors
description: "Detailed reference for writing Nushell actors that react to frames, manage state, and emit new events"
sidebar:
  order: 3
---

import { Aside, Tabs, TabItem } from '@astrojs/starlight/components';

import { Link } from '../../../utils/links';

cross.stream actors use <Link to="nu" />
[closures](https://www.nushell.sh/lang-guide/chapters/types/basic_types/closure.html)
to process and act on incoming frames as they are appended to the store.

```nushell
{
  run: {|frame, state|
    if $frame.topic == "ping" {
      {out: "pong", next: $state}
    } else {
      {next: $state}
    }
  }
}
```

The actor closure receives each new frame and the current state value. It returns a record that controls output and state:

- `{out: value, next: state}` -- emit `value`, continue with new `state`
- `{next: state}` -- no output, continue with new `state`
- `{out: value}` -- emit `value`, then self-terminate
- `null` / nothing -- self-terminate, no output

The `out` value gets automatically appended to `<actor-name>.out`. The closure can also explicitly append frames using the `.append` command.

## Registering

To register an actor, append a registration script with the topic
`<actor-name>.register`. The script must return a record that configures the
actor's behavior:

```nushell
r###'{
  # Required: Actor closure (frame, state) -> {out?, next?}
  run: {|frame, state|
    if $frame.topic == "ping" {
      {out: "pong", next: $state}
    } else {
      {next: $state}
    }
  }

  # Optional: Where to start processing from
  # "new" (default), "first", or scru128 ID
  start: "new"

  # Optional: Heartbeat interval in ms
  pulse: 1000

  # Optional: Control output frame behavior
  return_options: {
    suffix: ".response" # Output topic suffix
    ttl: "last:1" # Keep only most recent frame
  }
}'### | .append echo.register
```

The `run` closure must accept **exactly two positional arguments**: the incoming
frame and the current state value.

The registration script is stored in CAS and evaluated to obtain the actor's
configuration.

Upon a successful start the actor appends a `<actor-name>.active` frame
with metadata:

- `actor_id` -- the ID of the actor instance
- `new` -- whether processing started from the end of the topic (new items only)
- `after` -- the frame ID that processing resumed after (if any)

### Configuration Record Fields

| Field            | Description                                                                |
| ---------------- | -------------------------------------------------------------------------- |
| `run`            | Required actor closure `{\|frame, state\| -> {out?, next?}}`              |
| `initial`        | Initial state value (default: null, or the closure param default)          |
| `start`          | "new" (default), "first", or scru128 ID to control where processing starts |
| `pulse`          | Interval in milliseconds to send synthetic xs.pulse events                 |
| `return_options` | Controls output frames: see Return Options                                 |

#### Return Options

The `return_options` field controls how return values are handled:

- `suffix`: String appended to actor's name for output topic (default: ".out")
- `ttl`: Time-to-live for output frames
  - `"forever"`: Never expire
  - `"ephemeral"`: Not stored; only active subscribers receive it
  - `"time:<milliseconds>"`: Expire after duration
  - `"last:<n>"`: Keep only N most recent frames

#### Modules

Actors can use modules registered via `*.nu` topics. An actor sees the modules as they existed when it was registered. See <Link to="/reference/topics/#module-topics">Module Topics</Link> for details.

```nushell
r###'{
  run: {|frame, state|
    use xs/my-math
    {out: (my-math double 8), next: $state}
  }
}'### | .append processor.register
```

## State

Actors thread state explicitly through the `next` key in the return record. The
second closure parameter receives the current state, and `next` sets the state
for the next invocation:

```nushell
r#'{
  run: {|frame, state|
    let count = $state + 1
    {out: $"Processed ($count) frames", next: $count}
  }
  initial: 0
}'# | .append counter.register
```

The initial state is resolved in order:

1. The `initial` field in the config record
2. The default value on the closure's second parameter (e.g. `state = 0`)
3. `null` if neither is provided

## Output

Actors can produce output in two ways:

1. **Return Values**: The `out` key in the return record is automatically
   appended to the actor's output topic (`<actor-name>.out` by default unless
   modified by return_options.suffix)

```nushell
{|frame, state|
  if $frame.topic == "ping" {
    {out: "pong", next: $state}
  } else {
    {next: $state}
  }
}
```

2. **Explicit Appends**: Use the `.append` command to create frames on any topic

```nushell
{|frame, state|
  if $frame.topic == "ping" {
    "pong" | .append response.topic --meta { "type": "response" }
    "logged" | .append audit.topic
    {next: $state}
  } else {
    {next: $state}
  }
}
```

All output frames automatically include:

- `actor_id`: ID of the actor that created the frame
- `frame_id`: ID of the frame that triggered the actor
- Frames with `meta.actor_id` equal to the actor's ID are ignored to avoid
  reacting to the actor's own output

## Lifecycle

See <Link to="/reference/topics/">Topics</Link> for all processor suffixes.

```mermaid
stateDiagram-v2
    [*] --> Activating: .register event
    Activating --> Unregistered: nushell parse error
    Activating --> Active : parse OK
    Unregistered --> [*]

    state Active {
        direction LR
        [*] --> events.recv()
        events.recv() --> should_run: event received

        should_run --> events.recv(): skip
        should_run --> process_event: yep
        should_run --> [*]: .unregister event

        process_event --> [*]: error encountered
        process_event --> [*]: self-terminated (no next key)
        process_event --> events.recv(): OK
    }

    Active --> Unregistered
```

### Unregistering

An actor can be unregistered by:

- Appending `<actor-name>.unregister`
- Registering a new actor with the same name
- Self-termination: returning `{out: value}`, `{}`, or `null` (no `next` key)
- Runtime errors in the actor closure

When unregistered, the actor appends a confirmation frame
`<actor-name>.unregistered`. If unregistered due to an error, the frame
includes an `error` field in its metadata.

### Error Handling

If an actor encounters an error during execution:

1. The actor is automatically unregistered
2. A frame is appended to `<actor-name>.unregistered` with:
   - The error message in metadata
   - Reference to the triggering frame
