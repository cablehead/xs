---
title: Core Concepts
description: Understanding the fundamental concepts behind cross.stream's architecture and operation
sidebar:
  order: 3
---

cross.stream is built around three fundamental concepts that work together to
create a powerful and flexible event streaming system: the event store,
generators, and handlers. Let's explore how these components interact and
complement each other.

## Event Store: The Foundation

At its core, cross.stream is an event store - a specialized database that
maintains an append-only log of events. Think of it as a ledger where each entry
(called a frame) represents something that happened, complete with metadata
about when and how it occurred.

The event store provides a few key capabilities:

- **Append-only writes**: New events can only be added to the end of the stream,
  preserving the historical record
- **Content separation**: Event metadata is stored separately from content,
  optimizing for both quick scanning and efficient content storage
- **Real-time subscriptions**: Clients can follow the stream live, receiving new
  events as they occur

This design makes the event store particularly good at maintaining an accurate
history of what happened and when, while still being efficient to query and
process.

## Generators: The Producers

Generators are like automated watchers that produce new events into the stream.
They run as background processes, monitoring for specific conditions or changes
and emitting corresponding events when they occur.

For example, a generator might:

- Watch a log file and emit new lines as events
- Monitor a websocket connection and turn incoming messages into events
- Periodically check a system's status and emit health events

What makes generators powerful is their ability to:

- Run continuously in the background
- Automatically restart if they encounter issues
- Handle bi-directional communication when needed (with the `duplex` option)
- Emit standardized lifecycle events (start, stop, error)

Think of generators as the sensors of your system - they watch, listen, and
report what they observe into the event stream.

## Handlers: The Reactors

Handlers complete the picture by providing a way to react to and process events
in the stream. They are like event-driven functions that wake up when new events
arrive, process them according to rules you define, and optionally produce new
events in response.

Key characteristics of handlers include:

- They process events using Nushell expressions
- They can maintain state between executions
- They can emit new events into the stream
- They automatically track which events they've processed

Handlers turn your event store from a passive recording system into an active
processing pipeline. They can:

- Transform events into new formats
- Trigger external actions in response to events
- Aggregate or analyze event data
- Create chains of event processing

## How They Work Together

These three concepts form a powerful event processing system:

1. The **event store** provides the reliable foundation, ensuring events are
   durably stored and efficiently retrievable
2. **Generators** feed the system with events from external sources
3. **Handlers** process those events, potentially generating new events that
   feed back into the system

This creates a flexible architecture where:

- Multiple generators can feed events into the system
- Multiple handlers can process the same events in different ways
- The event store ensures everything is reliably recorded and retrievable

For example, you might have:

- A generator watching a log file
- A handler that filters for error events and creates alerts
- Another handler that aggregates statistics
- A third handler that archives old events

Each component focuses on its specific role while working together to create a
complete event processing system.

## Choosing the Right Approach

When working with cross.stream, consider:

- Use the **event store directly** when you need to manually record events or
  query the history
- Use **generators** when you need to automatically produce events from external
  sources
- Use **handlers** when you need to process, transform, or react to events in
  the stream

The beauty of this design is that you can start simple - perhaps just using the
event store directly - and gradually add generators and handlers as your needs
grow more complex.
