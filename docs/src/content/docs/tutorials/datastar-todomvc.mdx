---
title: TodoMVC with Datastar
description: Learn to build reactive web apps using the hypermedia approach where backend drives UI updates via immediate mode HTML streaming
sidebar:
  order: 3
---

import { Aside } from "@astrojs/starlight/components";

This tutorial demonstrates the hypermedia/immediate mode approach to web development: backend-first development where the server drives UI updates by streaming HTML fragments to the client.

<Aside type="tip">
  See the complete working example at{" "}
  <a
    href="https://github.com/cablehead/xs/tree/main/examples/datastar-todomvc"
    target="_blank"
    rel="noopener noreferrer"
  >
    xs/examples/datastar-todomvc
  </a>
  .
</Aside>

## What You'll Learn

- Event sourcing with xs streams
- Server-driven UI updates via Server-Sent Events streaming HTML fragments, no client-side state management
- [Datastar](https://data-star.dev/) reactive bindings
- Hypermedia principles: server owns all state, UI is pure projection

## Prerequisites

- [xs](https://github.com/cablehead/xs) running
- [minijinja-cli](https://github.com/mitsuhiko/minijinja) for templating
- [http-nu](https://github.com/cablehead/http-nu) for serving

## Tutorial Steps

### 1. Add Your First Event

Start by adding a todo event to the stream:

```bash
.append todos --meta {action: "add", text: "Learn event sourcing"}
```

### 2. See the Event

Check what's in the store:

```bash
.cat | where topic == "todos"
```

You'll see your event with:

- `topic: "todos"`
- `meta.action: "add"`
- `meta.text: "Learn event sourcing"`
- An auto-generated `id`

### 3. Add Another Event

```bash
.append todos --meta {action: "add", text: "Build something cool"}
```

Check the stream again:

```bash
.cat | where topic == "todos"
```

Now you see two events. This is the fundamental concept: **events are immutable and append-only**.

### 4. Completing a Todo

Now you want to mark the first todo as complete. With event streams, you express updates by appending more events:

```bash
.append todos --meta {action: "toggle", id: "1"}
```

The metadata structure is arbitrary but follows common patterns:

- `action`: what operation (add, toggle, delete, etc.)
- `id`: which item to operate on
- Other fields as needed (`text`, `completed`, etc.)

Check the stream:

```bash
.cat | where topic == "todos"
```

You now have three events: two "add" events and one "toggle" event.

### 5. Aggregated View

Raw events aren't useful for the UI. You need current state. Use an ad-hoc generator to aggregate events into state:

```bash
.cat | where topic == "todos" | generate {|frame, state = {todos: []}|
  match $frame.meta.action {
    "add" => {
      next: ($state | update todos {append {id: $frame.id, text: $frame.meta.text, completed: false}})
    }
    "toggle" => {
      next: ($state | update todos {each {|todo|
        if $todo.id == $frame.meta.id {
          {id: $todo.id, text: $todo.text, completed: (not $todo.completed)}
        } else {
          $todo
        }
      }})
    }
    _ => {next: $state}
  }
} | last
```

This shows the current aggregated state: a list of todos with their completion status.

### 6. Real-Time Processing

The complete app uses `project_todo_state` to continuously process the event stream and generate HTML for the browser:

```bash
# Add threshold to trigger live updates
.append xs.threshold

# Watch live state processing
.cat -f | project_todo_state | where active_count? != null
```

Every new event automatically triggers state recalculation and HTML updates to connected browsers.

## Key Concepts

**Event Sourcing**: Every change is an immutable event in the stream. Current state is derived by replaying events.

**Immediate Mode**: Like game engines, the server continuously renders the complete UI state and sends updates.

**Server-Side Truth**: No client-side state synchronization problems. The server owns all state transitions.

**Hypermedia**: HTML is the application state. UI updates are HTML fragments, not JSON data.

## Next Steps

- Explore the complete example implementation
- Try building your own hypermedia applications
- Experiment with different Datastar reactive patterns
- Scale to multiple concurrent users via xs's built-in event broadcasting
