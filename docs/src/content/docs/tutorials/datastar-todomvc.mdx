---
title: TodoMVC with Datastar
description: Learn to build reactive web apps using the hypermedia approach where backend drives UI updates via immediate mode HTML streaming
sidebar:
  order: 3
---

import { Aside } from "@astrojs/starlight/components";

This tutorial demonstrates the hypermedia/immediate mode approach to web development: backend-first development where the server drives UI updates by streaming HTML fragments to the client. We'll use [Datastar](https://data-star.dev/) for reactive frontend bindings.

<Aside type="tip">
  See the complete working example at{" "}
  <a
    href="https://github.com/cablehead/xs/tree/main/examples/datastar-todomvc"
    target="_blank"
    rel="noopener noreferrer"
  >
    xs/examples/datastar-todomvc
  </a>
  .
</Aside>

## What You'll Learn

- Event sourcing with xs streams
- Server-driven UI updates via Server-Sent Events streaming HTML fragments, no client-side state management
- [Datastar](https://data-star.dev/) reactive bindings
- Hypermedia principles: server owns all state, UI is pure projection

## Prerequisites

- [xs](https://github.com/cablehead/xs) running
- [minijinja-cli](https://github.com/mitsuhiko/minijinja) for templating
- [http-nu](https://github.com/cablehead/http-nu) for serving

## Add a Todo

OK! Let's start by adding a todo event to the stream:

```bash withOutput
> .append todos --meta {action: "add", text: "Learn event sourcing"}
───────┬─────────────────────────────────────────────────────
 topic │ todos
 id    │ 03elvd78yq84vp6botmro8jyt
 hash  │
 meta  │ ────────┬──────────────────────
       │  action │ add
       │  text   │ Learn event sourcing
       │ ────────┴──────────────────────
 ttl   │
───────┴─────────────────────────────────────────────────────
```

## See the Event

Check what's in the store:

```bash withOutput
> .cat | where topic == "todos"
─#─┬─topic─┬────────────id─────────────┬─hash─┬──────────────meta───────────────
 0 │ todos │ 03elvd78yq84vp6botmro8jyt │      │ ────────┬──────────────────────
   │       │                           │      │  action │ add
   │       │                           │      │  text   │ Learn event sourcing
   │       │                           │      │ ────────┴──────────────────────
───┴───────┴───────────────────────────┴──────┴─────────────────────────────────
```

You'll see your event with:

- `topic: "todos"`
- `meta.action: "add"`
- `meta.text: "Learn event sourcing"`
- An auto-generated `id`

## Add Another Todo

Now let's add a second todo and capture the returned frame:

```bash withOutput
> let todo = .append todos --meta {action: "add", text: "Build something cool"}
> $todo
───────┬─────────────────────────────────────────────────────
 topic │ todos
 id    │ 03elvd8txt25bf13qyggp0cdp
 hash  │
 meta  │ ────────┬──────────────────────
       │  action │ add
       │  text   │ Build something cool
       │ ────────┴──────────────────────
 ttl   │
───────┴─────────────────────────────────────────────────────
```

Check the stream again:

```bash withOutput
> .cat | where topic == "todos"
─#─┬─topic─┬────────────id─────────────┬─hash─┬──────────────meta───────────────
 0 │ todos │ 03elvd78yq84vp6botmro8jyt │      │ ────────┬──────────────────────
   │       │                           │      │  action │ add
   │       │                           │      │  text   │ Learn event sourcing
   │       │                           │      │ ────────┴──────────────────────
 1 │ todos │ 03elvd8txt25bf13qyggp0cdp │      │ ────────┬──────────────────────
   │       │                           │      │  action │ add
   │       │                           │      │  text   │ Build something cool
   │       │                           │      │ ────────┴──────────────────────
───┴───────┴───────────────────────────┴──────┴─────────────────────────────────
```

Now you see two events. This is the fundamental concept: **events are immutable and append-only**.

## Completing a Todo

Now we want to mark the second todo as complete. With event streams, you express updates by appending more events:

```bash withOutput
> .append todos --meta {action: "toggle", id: $todo.id}
───────┬─────────────────────────────────────────────────────
 topic │ todos
 id    │ 03elvdlutpeeusqvf1xfdf7ig
 hash  │
 meta  │ ────────┬───────────────────────────
       │  action │ toggle
       │  id     │ 03elvd8txt25bf13qyggp0cdp
       │ ────────┴───────────────────────────
 ttl   │
───────┴─────────────────────────────────────────────────────
```

The metadata structure is arbitrary but follows common patterns:

- `action`: what operation (add, toggle, delete, etc.)
- `id`: which item to operate on
- Other fields as needed (`text`, `completed`, etc.)

Check the stream:

```bash withOutput
> .cat | where topic == "todos"
─#─┬─topic─┬────────────id─────────────┬─hash─┬──────────────meta───────────────
 0 │ todos │ 03elvd78yq84vp6botmro8jyt │      │ ────────┬──────────────────────
   │       │                           │      │  action │ add
   │       │                           │      │  text   │ Learn event sourcing
   │       │                           │      │ ────────┴──────────────────────
 1 │ todos │ 03elvd8txt25bf13qyggp0cdp │      │ ────────┬──────────────────────
   │       │                           │      │  action │ add
   │       │                           │      │  text   │ Build something cool
   │       │                           │      │ ────────┴──────────────────────
 2 │ todos │ 03elvdlutpeeusqvf1xfdf7ig │      │ ────────┬───────────────────────────
   │       │                           │      │  action │ toggle
   │       │                           │      │  id     │ 03elvd8txt25bf13qyggp0cdp
   │       │                           │      │ ────────┴───────────────────────────
───┴───────┴───────────────────────────┴──────┴─────────────────────────────────
```

You now have three events: two "add" events and one "toggle" event.

## Aggregated View

Raw events are awkward for presenting a summary of the current state of things. We want to create a projection of the stream. We can use an ad-hoc generator to aggregate events into state:

```bash withOutput
> .cat | where topic == "todos" | generate {|frame, state = []|
  match $frame.meta.action {
    "add" => {
      let new_state = ($state | append {id: $frame.id, text: $frame.meta.text, completed: false})
      {out: $new_state, next: $new_state}
    }
    "toggle" => {
      let new_state = ($state | each {|todo|
        if $todo.id == $frame.meta.id {
          {id: $todo.id, text: $todo.text, completed: (not $todo.completed)}
        } else {
          $todo
        }
      })
      {out: $new_state, next: $new_state}
    }
    _ => {next: $state}
  }
} | last
─#─┬────────────id─────────────┬─────────text─────────┬─completed─
 0 │ 03elvd78yq84vp6botmro8jyt │ Learn event sourcing │ false
 1 │ 03elvd8txt25bf13qyggp0cdp │ Build something cool │ true
───┴───────────────────────────┴──────────────────────┴───────────
```

This shows the current aggregated state: a list of todos with their completion status.
